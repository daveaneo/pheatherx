# FheatherXv8FHE.sol Comprehensive Audit

**Audit Date:** 2025-12-15
**Contract:** `contracts/src/FheatherXv8FHE.sol`
**Version:** v8
**Auditor:** Claude Code

---

## Executive Summary

| Category | Status | Severity |
|----------|--------|----------|
| Binary Search Momentum Closure | CRITICAL | Must fix before production |
| Missing 100% Liquidity Cap | HIGH | Security vulnerability |
| Fixed Momentum Estimate | HIGH | Incorrect behavior |
| Pro-Rata vs Priority Slicing | MEDIUM | Differs from spec |
| Limit Order Price Semantics | MEDIUM | Differs from spec |
| Division Safety | PASS | Correctly handled |
| FHE ACL Permissions | PASS | Systematically applied |
| Reentrancy Protection | PASS | Transient storage guard |

---

## Contract Overview

FheatherXv8FHE is a Uniswap v4 Hook implementing:
- **Full privacy pools** (FHERC20:FHERC20 only)
- **Hybrid AMM + Limit Orders** with momentum activation
- **Encrypted reserves** with async plaintext sync
- **Single AMM execution** per swap (gas optimization)

### Key Constants
- `TICK_SPACING`: 60
- `MAX_TICK_MOVE`: 600 (10 ticks max per swap)
- `MAX_MOMENTUM_BUCKETS`: 5
- `BINARY_SEARCH_ITERATIONS`: 12
- `PRECISION`: 1e18

---

## CRITICAL ISSUES

### 1. Binary Search Phantom Fixed Point Problem

**Location:** `_findMomentumClosure()` lines 436-493

**Issue:**
The contract uses binary search to find momentum closure:

```solidity
for (uint8 i = 0; i < BINARY_SEARCH_ITERATIONS; i++) {
    if (lo >= hi) break;
    int24 mid = lo + (hi - lo) / 2;
    mid = (mid / TICK_SPACING) * TICK_SPACING;
    // ... predicate check
}
```

**Why This Fails:**
The tick-after function `f(t) = tick_after(user + orders_in_range(t))` is a **STEP FUNCTION** with discontinuities at each trigger tick. Binary search can find mathematically valid fixed points that are **UNREACHABLE** from the initial state.

**Example:**
```
User swap alone → tick = 21
Order A: trigger=1, amount=0.001 (small)
Order B: trigger=22, amount=1.0 (large)

f(t) for t in [1, 22):  f(t) = 21  (only A)
f(t) for t in [22, ∞):  f(t) = 1926 (A + B)

REAL fixed point: t=21 (reachable via cascade)
Binary search finds: t=1926 (phantom - unreachable)
```

**Impact:**
- Over-activation of momentum orders
- Different final price than expected
- User receives less output

**Recommendation:**
Replace with iterative tick expansion:
```solidity
int24 current = startTick;
for (uint8 i = 0; i < MAX_MOMENTUM_BUCKETS + 2; i++) {
    uint256 momentumSum = _sumMomentumBucketsPlaintext(poolId, zeroForOne, startTick, current);
    uint256 totalIn = userRemainderPlaintext + momentumSum;
    int24 nextTick = _tickAfterSwap(reserves, totalIn, zeroForOne);
    if (zeroForOne ? nextTick >= current : nextTick <= current) break;
    current = nextTick;
}
```

---

### 2. Missing 100% Liquidity Cap

**Location:** `_sumMomentumBucketsEnc()` lines 532-564

**Issue:**
No check prevents orders larger than pool reserves from activating:

```solidity
// Missing check:
// if (bucket.liquidity > reserve) skip
```

**Impact:**
- Orders exceeding pool size could activate
- Causes extreme slippage (>50% price impact)
- Enables griefing attacks

**Recommendation:**
```solidity
uint256 reserveLimit = zeroForOne ? reserves.reserve1 : reserves.reserve0;
// In _sumMomentumBucketsEnc loop:
if (estimatedLiquidity > reserveLimit) continue; // Skip oversized buckets
```

---

### 3. Fixed Momentum Estimate

**Location:** `_findMomentumClosure()` line 463

**Issue:**
```solidity
uint256 momentumEstimate = uint256(bucketCount) * 1e18;
```

Uses fixed 1e18 per bucket instead of actual liquidity.

**Impact:**
- Inaccurate tick prediction
- Binary search converges to wrong answer
- May under/over-activate buckets

**Recommendation:**
Sum actual bucket liquidity from plaintext cache.

---

## HIGH PRIORITY ISSUES

### 4. Pro-Rata vs Priority Slicing

**Location:** `_allocateVirtualSlicing()` lines 575-617

**Current Implementation:**
```solidity
euint128 bucketOutput = FHE.div(
    FHE.mul(bucket.liquidity, totalOutput),
    safeDenom
);
```

All participants get the **same average price**.

**Specification (momentum.py):**
Priority-based virtual curve slicing gives **better price to earlier triggers**.

**Impact:**
- User at t0 should get best price but doesn't
- Momentum orders get same price as user
- Differs from documented behavior

**Recommendation:**
Document as intentional design decision OR implement prefix-sum virtual slicing.

---

### 5. Limit Order Price Semantics

**Location:** `_fillOpposingBucket()` lines 395-430

**Current:**
```solidity
euint128 encTickPrice = FHE.asEuint128(uint128(FheatherMath.calculateTickPrice(tick)));
outputToUser = FHE.div(FHE.mul(fill, encTickPrice), ENC_PRECISION);
```

Matches at **bucket's tick price**.

**Specification:**
Should match at **AMM spot price** (current_price from reserves).

**Impact:**
- If limit_tick < current_tick, maker gets worse execution
- Inconsistent with POC design

---

## PASSING CHECKS

### Division Safety
**Status:** PASS

```solidity
euint128 safeDenominator = FHE.select(
    FHE.gt(denominator, ENC_ZERO),
    denominator,
    ENC_ONE
);
```

All FHE.div operations use safe denominator pattern.

### FHE ACL Permissions
**Status:** PASS

Systematic use of:
- `FHE.allowThis(value)` after creating encrypted values
- `FHE.allow(value, recipient)` before transfers

### Reentrancy Protection
**Status:** PASS

Uses `SwapLockTransient` with EIP-1153 transient storage (100 gas vs 2100).

### Single AMM Execution
**Status:** PASS

Correctly batches user input + momentum orders into single `_executeSwapMath()` call.

---

## Architecture Analysis

### Swap Pipeline (6 Steps)

1. **Match Opposing Limits** - Fill limit orders at tick prices
2. **Binary Search Momentum** - Find activation tick (CRITICAL BUG)
3. **Sum Momentum Buckets** - Aggregate encrypted liquidity
4. **Execute AMM Once** - Single x*y=k calculation
5. **Virtual Slicing** - Allocate output to buckets (pro-rata)
6. **Reserve Sync** - Request async decrypt

### Reserve Synchronization

```solidity
_requestReserveSync(poolId):
  FHE.decrypt(encReserve0)
  FHE.decrypt(encReserve1)
  pendingDecrypts[poolId][requestId] = {...}

_harvestResolvedDecrypts(poolId):
  Binary search for newest resolved decrypt
  Update plaintext cache
```

**Concern:** Plaintext cache can become stale if no swaps occur. `trySyncReserves()` must be called externally.

---

## Data Structures

### PoolReserves
```solidity
struct PoolReserves {
    euint128 encReserve0;        // Encrypted source of truth
    euint128 encReserve1;
    euint128 encTotalLpSupply;
    uint256 reserve0;            // Plaintext cache
    uint256 reserve1;
    uint256 totalLpSupply;
    uint256 reserveBlockNumber;
    uint256 nextRequestId;
    uint256 lastResolvedId;
}
```

### Bucket
```solidity
struct Bucket {
    euint128 totalShares;
    euint128 liquidity;
    euint128 proceedsPerShare;   // Accumulator
    euint128 filledPerShare;     // Accumulator
    bool initialized;
}
```

---

## Recommendations Summary

| Priority | Issue | Action |
|----------|-------|--------|
| CRITICAL | Binary search | Replace with iterative expansion |
| HIGH | Liquidity cap | Add 100% reserve check |
| HIGH | Momentum estimate | Use actual liquidity values |
| MEDIUM | Virtual slicing | Document or implement priority |
| MEDIUM | Limit price | Consider AMM spot price |
| LOW | Reserve staleness | Document trySyncReserves requirement |

---

## Related Audits

- `docs/audit/matching_audit_fhe.md` - Detailed matching algorithm analysis
- `docs/audit/2025-12-15-v8Mixed-audit.md` - Mixed pair variant
- `docs/audit/2025-12-15-v8-tests-audit.md` - Test coverage analysis
