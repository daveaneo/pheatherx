REPORT: SCALABILITY BOTTLENECKS & OPTIMIZATION STRATEGY
1. THE ISSUE: THE "CONSTANT TIME" TRAP
The core conflict in your architecture is between Privacy (Anti-Probing) and Scalability (Gas Limits).
To prevent an attacker from determining if an order was filled by measuring gas usage, your contract executes the full swap mathematics for every single limit order sitting at a crossed tick, regardless of whether that order is actually triggered or filled.
The Bottleneck:
Inside _processOrdersAtTick, you are iterating through an array. Inside that loop, you call _fillOrderConditional, which calls _executeSwapMathConditional.
This function performs Encrypted Division (FHE.div).
In Homomorphic Encryption, division is the most computationally expensive operation by a massive margin (orders of magnitude more expensive than addition, and significantly more than multiplication).
The Consequence:
If a standard Ethereum block gas limit is 30M, and a single FHE division consumes a significant portion of "FHE Gas" (or computation time), your contract will likely hit the Out Of Gas (OOG) limit with as few as 2 to 5 concurrent orders at a single tick. This renders the limit order feature unusable for a public ecosystem.
2. MATHEMATICAL & OPERATIONAL OPTIMIZATIONS
To scale this, we must aggressively reduce the complexity of the encrypted operations inside the loop.
A. Remove Division from Fees and Rewards
Currently, you calculate fees and executor rewards using standard percentage math:
reward = (amount * 1) / 100
Optimization:
Eliminate FHE.div for these auxiliary calculations. Use Bitwise Shifts (FHE.shr) instead.
Instead of a 1% fee (div 100), use a
1
/
128
1/128
 fee (shift right 7 bits).
Instead of an arbitrary swap fee, align fees to powers of 2 (e.g.,
1
/
256
1/256
,
1
/
512
1/512
).
Impact: Removes 2 expensive division operations per order (one for the swap fee, one for the executor reward).
B. The "Lazy" AMM Math (Constant Sum vs Product)
Constant Product (
x
⋅
y
=
k
x⋅y=k
) forces you to calculate
d
x
=
(
x
⋅
d
y
)
/
(
y
+
d
y
)
dx=(x⋅dy)/(y+dy)
. That division is unavoidable in Uniswap v2/v4 logic.
Optimization:
Consider a hybrid approach for Limit Orders only:
Treat limit orders as Constant Sum fills (
p
r
i
c
e
⋅
a
m
o
u
n
t
price⋅amount
).
If I place a limit order to sell 1 ETH at 2000 USDC, simply multiply 1 * 2000 to get the output.
Impact: Replaces FHE.div with FHE.mul. Multiplication is significantly cheaper than division in FHE. This changes the financial model slightly (limit orders don't act as AMM liquidity curves but as point-fills), but strictly aligns with traditional order book logic.
C. Remove Token Transfers from the Loop
Currently, you call fheToken.transferEncryptedDirect inside the loop.
This function likely involves re-encryption and state updates within the FHERC20 contract.
Doing this
N
N
 times causes massive overhead.
Optimization:
Accumulate the "Net Settle" amounts.
Initialize an encrypted accumulator euint128 totalToken0Out = ENC_ZERO.
Inside the loop, add the order's output to the accumulator: totalToken0Out = FHE.add(totalToken0Out, currentOrderOut).
Perform one transfer at the end of the batch (or one per unique user).
Impact: Replaces
N
N
 external calls with
N
N
 cheap FHE.add operations.
D. Pagination (Hard Gas Cap)
You cannot process an unbounded array.
Optimization:
Modify _checkAndProcessOrders to accept a maxOrdersToProcess parameter (or hardcode it to a safe number, e.g., 3).
If there are 10 orders at the tick, only process the first 3.
The swap completes, leaving 7 orders for the next swapper (or a dedicated "crank" transaction).
Impact: Prevents the contract from ever breaking the block gas limit, ensuring liveness even if the order queue is deep.
3. PROPOSED STRESS TEST
You need to empirically determine the "Breaking Point" (
N
m
a
x
N
max
​

).
Test Name: LimitOrderGasStressTest
Steps:
Setup: Deploy PheatherXv2 and two mock FHERC20 tokens.
Baseline:
Perform a swapEncrypted with 0 orders in the tick range.
Record Gas Used (
G
b
a
s
e
G
base
​

).
Increment:
Place 1 Limit Order at Tick 100.
Perform a swap that crosses Tick 100.
Record Gas Used (
G
1
G
1
​

).
Calculate cost per order:
C
o
r
d
e
r
=
G
1
−
G
b
a
s
e
C
order
​
 =G
1
​
 −G
base
​

.
Verify Linearity:
Reset. Place 3 Limit Orders at Tick 100.
Swap. Record Gas.
Verify if
G
a
s
≈
G
b
a
s
e
+
(
3
×
C
o
r
d
e
r
)
Gas≈G
base
​
 +(3×C
order
​
 )
.
Find the Cliff:
Calculate theoretically:
N
m
a
x
=
B
l
o
c
k
L
i
m
i
t
−
G
b
a
s
e
C
o
r
d
e
r
N
max
​
 =
C
order
​

BlockLimit−G
base
​

​

.
Attempt to execute a swap crossing
N
m
a
x
+
1
N
max
​
 +1
 orders.
Assert that the transaction fails (Reverts due to Out of Gas).
Expected Result:
Based on current FHE gas costs on Fhenix/Zama devnets, I predict
N
m
a
x
N
max
​

 will be extremely low (likely single digits) with the current code. Implementing Optimization 2.B (removing division) and 2.C (accumulating transfers) is required to push this number into a usable range.

======================
======================


1. PRIVACY: COARSE-GRAINED BUCKETING (WIDE TICKS)
The Problem: A standard bitmap (tick 100, tick 101) reveals user strategies with high precision.
The Fix: Enforce a wide tickSpacing (e.g., 60, 200, or even higher) for Encrypted Limit Orders.
Mechanism:
Users cannot place an order at Price 1001. They must place it in the Price Bucket [1000-1050].
All liquidity in this range is aggregated into a single EncryptedL variable.
Execution Price: All orders in the bucket execute at the boundary price (e.g., 1000).
Benefits:
Privacy: Observers see liquidity exists in a 2-5% range, but cannot pinpoint the exact stop-loss or entry level.
Gas Efficiency: Reduces the traversal space by a factor of 60x to 200x. The BitMath logic has to check significantly fewer slots.
Surplus Capture: Users effectively get a "surplus" if the fill happens at the boundary, which can be used to incentivize the Executor.
2. MATHEMATICS: BRANCHLESS FILL LOGIC
The Problem: We need to handle cases where the swapper's input is larger or smaller than the liquidity in the bucket, without using if/else (which leaks data) or branching (impossible in FHE).
The Fix: Use FHE.min to calculate the "Effective Fill" in one step.
The Algorithm (Per Bucket):
Price = Plaintext Constant (derived from bucket index).
MaxBucketCapacity = BucketLiquidity * Price.
The Branchless Step: AmountUsed = FHE.min(UserRemainingInput, MaxBucketCapacity).
AmountFilled = AmountUsed / Price (Use Scalar Math, or inverse multiplication).
UserRemainingInput = UserRemainingInput - AmountUsed.
BucketLiquidity = BucketLiquidity - AmountFilled.
Why this wins:
It handles Partial Fills (User runs out of money) and Full Bucket Sweeps (Bucket runs out of liquidity) with the exact same mathematical operation.
It consumes constant gas per bucket.
3. STATE MANAGEMENT: THE "CLAIM TICKET" (ERC-1155)
The Problem: Tracking who owns what part of the encrypted bucket without iterating user arrays.
The Fix: Tokenize the position using a modified ERC-1155 approach.
Mechanism:
When User A deposits 100 tokens into Bucket ID X:
Contract adds 100 to EncryptedBucketLiquidity[X].
Contract Mints 100 ShareTokens (ID X) to User A.
Global Accumulator: The contract tracks EncryptedCumulativeFilled[X].
Every time the bucket is filled, this accumulator increases.
Claiming: User A burns ShareTokens.
Contract calculates Payout = Shares * (CumulativeFilled - UserEntrySnapshot).
Benefit: The swap transaction interacts only with the Global Accumulator. It never touches user balances. The complexity of distribution is offloaded to the Claim transaction.
4. SAFETY: THE GAS GOVERNOR
The Problem: Even with wide buckets, a massive price swing could cross too many buckets.
The Fix: Hard-coded Loop Bound.
Mechanism:
uint256 constant MAX_BUCKETS_PER_SWAP = 3;
The loop runs a maximum of 3 times.
If the user's input is not fully exhausted after 3 buckets, the remaining tokens are returned to the user (encrypted refund).
User Experience: This effectively acts as a "Price Impact Limit". If a user tries to move the price 50% in one trade, it processes the first 3 chunks and refunds the rest. This guarantees the transaction never reverts due to gas, ensuring protocol liveness.